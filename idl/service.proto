// version 1.7

syntax = "proto3";

package protos;

/**
 * Enum representing the different view widths available in the soccer simulation.
 * For more information, see the documentation at [link](https://link.com).
 */
enum ViewWidth {
  NARROW = 0; // Narrow view width (60 degrees).
  NORMAL = 1; // Normal view width (90 degrees).
  WIDE = 2; // Wide view width (180 degrees).
}

/**
 * RpcVector2D represents a 2D vector with additional properties.
 * If you want to have access to geometric operations, you can use Vector2D class in [pyrusgeom package](https://github.com/Cyrus2D/PyrusGeom)
 * To use this class, you need to install pyrusgeom package, import Vector2D class and create a Vector2D object with x and y values.
 */
message RpcVector2D  {
  float x = 1; // The x-coordinate of the vector.
  float y = 2; // The y-coordinate of the vector.
  float dist = 3; // The distance magnitude of the vector.
  float angle = 4; // The angle of the vector in degrees. In soccer simulation 2D environment, the 0 degree is opponent's goal, and the angle increases in the counter-clock direction. So, if your team is in left side, -90 degree is up, 0 degree is right (opponent gole), 90 degree is down.
}

/**
  * RegisterRequest is the message that the client sends to the server to register itself.
  * The client should send this message to the server to register itself.
  * The server will respond with a RegisterResponse message.
  */
message RegisterRequest {
  AgentType agent_type = 1; // The type of the agent. It can be PlayerT, CoachT, or TrainerT.
  string team_name = 2; // The name of the team that the agent belongs to.
  int32 uniform_number = 3; // The uniform number of the agent.
  int32 rpc_version = 4; // The version of the RPC protocol that the client supports.
}

enum RpcServerLanguageType {
  UNKNOWN_LANGUAGE = 0;
  PYThON = 1;
  JAVA = 2;
  CPP = 3;
  CSHARP = 4;
  RUBY = 5;
  JAVE_SCRIPT = 6;
  GO = 7;
}

/**
  * RegisterResponse is the message that the server sends to the client in response to a RegisterRequest message.
  * The server will respond with this message after receiving a RegisterRequest message.
  * The client should use the information in this message to identify itself to the server.
  */
message RegisterResponse {
  int32 client_id = 1; // The unique identifier assigned to the client by the server.
  AgentType agent_type = 2; // The type of the agent. It can be PlayerT, CoachT, or TrainerT.
  string team_name = 3; // The name of the team that the agent belongs to.
  int32 uniform_number = 4; // The uniform number of the agent.
  RpcServerLanguageType rpc_server_language_type = 5; // The language that the server is implemented in.
}

/**
  * Ball is the message that represents the ball in the soccer simulation.
*/
message Ball {
  RpcVector2D  position = 1; // The position of the ball.
  RpcVector2D  relative_position = 2; // The relative position of the ball to the agent who is sending the message.
  RpcVector2D  seen_position = 3; // The position of the ball that the agent has seen.
  RpcVector2D  heard_position = 4; // The position of the ball that the agent has heard.
  RpcVector2D  velocity = 5; // The velocity of the ball.
  RpcVector2D  seen_velocity = 6; // The velocity of the ball that the agent has seen.
  RpcVector2D  heard_velocity = 7; // The velocity of the ball that the agent has heard.
  int32 pos_count = 8; // How many cycles ago the agent has seen or heard the ball.
  int32 seen_pos_count = 9; // How many cycles ago the agent has seen the ball.
  int32 heard_pos_count = 10; // How many cycles ago the agent has heard the ball.
  int32 vel_count = 11; // How many cycles ago the agent has seen or heard the velocity of the ball.
  int32 seen_vel_count = 12; // How many cycles ago the agent has seen the velocity of the ball.
  int32 heard_vel_count = 13; // How many cycles ago the agent has heard the velocity of the ball.
  int32 lost_count = 14; // How many cycles ago the agent has lost the ball.
  int32 ghost_count = 15;
  float dist_from_self = 16; // The distance of the ball from the agent who is sending the message.
  float angle_from_self = 17; // The angle of the ball from the agent who is sending the message.
}

enum Side {
  UNKNOWN = 0;
  LEFT = 1;
  RIGHT = 2;
}

enum LoggerLevel{
  NoneLevel = 0;
  SYSTEM = 0x00000001;
  SENSOR = 0x00000002;
  WORLD = 0x00000004;
  ACTION = 0x00000008;
  INTERCEPT = 0x00000010;
  KICK = 0x00000020;
  HOLD = 0x00000040;
  DRIBBLE = 0x00000080;
  PASS = 0x00000100;
  CROSS = 0x00000200;
  SHOOT = 0x00000400;
  CLEAR = 0x00000800;
  BLOCK = 0x00001000;
  MARK = 0x00002000;
  POSITIONING = 0x00004000;
  ROLE = 0x00008000;
  TEAM = 0x00010000;
  COMMUNICATION = 0x00020000;
  ANALYZER = 0x00040000;
  ACTION_CHAIN = 0x00080000;
  PLAN = 0x00100000;
  // TRAINING = 0x80000000;
  // LEVEL_ANY = 0xffffffff;
}

/**
  * Type of player's card.
*/
enum CardType {
  NO_CARD = 0;
  YELLOW = 1;
  RED = 2;
}

message PenaltyKickState {
  Side on_field_side = 1;
  Side current_taker_side = 2;
  int32 our_taker_counter = 3;
  int32 their_taker_counter = 4;
  int32 our_score = 5;
  int32 their_score = 6;
  bool is_kick_taker = 7;
}

/**
  * Player is the message that represents a player in the soccer simulation.
  * To get type information of the player, you can use the type_id field and player type information.
*/
message Player {
  RpcVector2D  position = 1; // The position of the player.
  RpcVector2D  seen_position = 2; // The position of the player that the agent has seen.
  RpcVector2D  heard_position = 3; // The position of the player that the agent has heard.
  RpcVector2D  velocity = 4; // The velocity of the player.
  RpcVector2D  seen_velocity = 5; // The velocity of the player that the agent has seen.
  int32 pos_count = 6; // How many cycles ago the agent has seen or heard the player.
  int32 seen_pos_count = 7; // How many cycles ago the agent has seen the player.
  int32 heard_pos_count = 8; // How many cycles ago the agent has heard the player.
  int32 vel_count = 9; // How many cycles ago the agent has seen or heard the velocity of the player.
  int32 seen_vel_count = 10; // How many cycles ago the agent has seen the velocity of the player.
  int32 ghost_count = 11; // How many cycles ago the agent has lost the player.
  float dist_from_self = 12; // The distance of the player from the agent who is sending the message.
  float angle_from_self = 13; // The angle of the player from the agent who is sending the message.
  int32 id = 14; // The unique identifier of the player.
  Side side = 15; // The side of the player. It can be LEFT or RIGHT or UNKNOWN if the side is not known.
  int32 uniform_number = 16;  // The uniform number of the player.
  int32 uniform_number_count = 17; // How many cycles ago the agent has seen the uniform number of the player.
  bool is_goalie = 18; // Whether the player is a goalie or not.
  float body_direction = 19; // The body direction of the player.
  int32 body_direction_count = 20; // How many cycles ago the agent has seen the body direction of the player.
  float face_direction = 21; // The face direction of the player. In soccer simulation 2D, face direction is the direction that the player is looking at.
  int32 face_direction_count = 22; // How many cycles ago the agent has seen the face direction of the player.
  float point_to_direction = 23; // The direction that the player is pointing to.
  int32 point_to_direction_count = 24; // How many cycles ago the agent has seen the point to direction of the player.
  bool is_kicking = 25; // Whether the player is kicking or not.
  float dist_from_ball = 26; // The distance of the player from the ball.
  float angle_from_ball = 27; // The angle of the player from the ball.
  int32 ball_reach_steps = 28; // How many cycles the player needs to reach the ball.
  bool is_tackling = 29; // Whether the player is tackling or not.
  int32 type_id = 30; // The type identifier of the player.
}

/**
  * Self is the message that represents the agent itself in the soccer simulation.
  * When an agent send a message to the playmaker server, self is information about the agent itself.
*/
message Self {
  RpcVector2D  position = 1; // The position of the agent.
  RpcVector2D  seen_position = 2; // The position of the agent that the agent has seen. (By using flags)
  RpcVector2D  heard_position = 3; // The position of the agent that the agent has heard. (This is not very useful)
  RpcVector2D  velocity = 4; // The velocity of the agent.
  RpcVector2D  seen_velocity = 5; // The velocity of the agent that the agent has seen. (By using flags)
  int32 pos_count = 6; // How many cycles ago the agent has seen or heard itself.
  int32 seen_pos_count = 7; // How many cycles ago the agent has seen itself.
  int32 heard_pos_count = 8; // How many cycles ago the agent has heard itself.
  int32 vel_count = 9; // How many cycles ago the agent has seen or heard the velocity of itself.
  int32 seen_vel_count = 10; // How many cycles ago the agent has seen the velocity of itself.
  int32 ghost_count = 11; // How many cycles ago the agent has lost itself.
  int32 id = 12; // The ID number for this object in proxy.
  Side side = 13; // The side of the agent. It can be LEFT or RIGHT or UNKNOWN if the side is not known.
  int32 uniform_number = 14; // The uniform number of the agent.
  int32 uniform_number_count = 15; // How many cycles ago the agent has seen the uniform number of itself.
  bool is_goalie = 16; // Whether the agent is a goalie or not.
  float body_direction = 17; // The body direction of the agent.
  int32 body_direction_count = 18; // How many cycles ago the agent has seen the body direction of itself.
  float face_direction = 19; // The face direction of the agent. In soccer simulation 2D, face direction is the direction that the agent is looking at. This is a global direction.
  int32 face_direction_count = 20; // How many cycles ago the agent has seen the face direction of itself.
  float point_to_direction = 21; // The direction that the agent is pointing to. This is a global direction.
  int32 point_to_direction_count = 22; // How many cycles ago the agent has seen the point to direction of itself.
  bool is_kicking = 23; // Whether the agent is kicking or not.
  float dist_from_ball = 24; // The distance of the agent from the ball.
  float angle_from_ball = 25; // The angle of the agent from the ball.
  int32 ball_reach_steps = 26; // How many cycles the agent needs to reach the ball.
  bool is_tackling = 27; // Whether the agent is tackling or not.
  float relative_neck_direction = 28; // The relative neck direction of the agent to the body direction.
  float stamina = 29; // The stamina of the agent. This number is between TODO
  bool is_kickable = 30; // Whether the agent is kickable or not. Means the agent can kick the ball.
  float catch_probability = 31; // The probability of the agent to catch the ball. This number is important for goalies.
  float tackle_probability = 32; // The probability of the agent to tackle the ball.
  float foul_probability = 33; // The probability of the agent to foul.
  ViewWidth view_width = 34; // The view width of the agent. It can be NARROW, NORMAL, or WIDE.
  int32 type_id = 35; // The type identifier of the agent. The RcssServer generates 18 different types of agents. The coach is reponsible to give the type information to the agent.
  float kick_rate = 36; // The kick rate of the agent. This number is calculated by this formula: self.playerType().kickRate(wm.ball().distFromSelf(), (wm.ball().angleFromSelf() - self.body()).degree()), So, if the kick rate is more, the agent can kick the ball with more first speed to any angle.
  float recovery = 37; // The current estimated recovery value. TODO more info
  float stamina_capacity = 38; // The stamina capacity of the agent. This number is between 0 to ~130000 depending on the server param.
  CardType card = 39; // The card type of the agent. It can be NO_CARD, YELLOW, or RED.
  int32 catch_time = 40; // The time when the last catch command is performed.
  float effort = 41; // The effort of the agent. TODO more info
}

/**
  * InterceptActionType is the enum that represents the different types of intercept actions.
*/
enum InterceptActionType {
  UNKNOWN_Intercept_Action_Type = 0; // Unknown intercept action type.
  OMNI_DASH = 1; // Omni dash intercept action type. Means the agent will dash to the ball in any direction.
  TURN_FORWARD_DASH = 2; // Turn forward dash intercept action type. Means the agent will turn to the ball and dash to the ball.
  TURN_BACKWARD_DASH = 3; // Turn backward dash intercept action type. Means the agent will turn to the ball and dash to the ball in the backward direction.
}

/**
  * InterceptInfo is the message that represents the information about an intercept action.
*/
message InterceptInfo {
  InterceptActionType action_type = 1; // The type of the intercept action.
  int32 turn_steps = 2; // The number of steps that the agent needs to turn to the ball.
  float turn_angle = 3; // The angle that the agent needs to turn to the ball.
  int32 dash_steps = 4; // The number of steps that the agent needs to dash to the ball.
  float dash_power = 5; // The power of the dash action.
  float dash_dir = 6; // The direction of the dash action to player's body direction.
  RpcVector2D  final_self_position = 7; // The final position of the agent after the intercept action.
  float final_ball_dist = 8; // The final distance of the ball from the agent after the intercept action.
  float final_stamina = 9; // The final stamina of the agent after the intercept action.
  float value = 10; // The value of the intercept action. TODO less is better or more is better?
}

/**
  * InterceptTable is the message that represents the intercept table of the agent.
*/
message InterceptTable {
  int32 self_reach_steps = 1; // The number of steps that the agent needs to reach the ball.
  int32 first_teammate_reach_steps = 2; // The number of steps that the first teammate needs to reach the ball.
  int32 second_teammate_reach_steps = 3; // The number of steps that the second teammate needs to reach the ball.
  int32 first_opponent_reach_steps = 4; // The number of steps that the first opponent needs to reach the ball.
  int32 second_opponent_reach_steps = 5; // The number of steps that the second opponent needs to reach the ball.
  int32 first_teammate_id = 6; // The ID of the first teammate. This ID is unique for each player's object in the each agent proxy. If the ID is 0, it means the agent has no first teammate.
  int32 second_teammate_id = 7; // The ID of the second teammate. This ID is unique for each player's object in the each agent proxy. If the ID is 0, it means the agent has no second teammate.
  int32 first_opponent_id = 8; // The ID of the first opponent. This ID is unique for each player's object in the each agent proxy. If the ID is 0, it means the agent has no first opponent.
  int32 second_opponent_id = 9; // The ID of the second opponent. This ID is unique for each player's object in the each agent proxy. If the ID is 0, it means the agent has no second opponent.
  repeated InterceptInfo self_intercept_info = 10; // The intercept information of the agent.
}

enum GameModeType {
  BeforeKickOff = 0;
  TimeOver = 1;
  PlayOn = 2;
  KickOff_ = 3;
  KickIn_ = 4;
  FreeKick_ = 5;
  CornerKick_ = 6;
  GoalKick_ = 7;
  AfterGoal_ = 8;
  OffSide_ = 9;
  PenaltyKick_ = 10;
  FirstHalfOver = 11;
  Pause = 12;
  Human = 13;
  FoulCharge_ = 14;
  FoulPush_ = 15;
  FoulMultipleAttacker_ = 16;
  FoulBallOut_ = 17;
  BackPass_ = 18;
  FreeKickFault_ = 19;
  CatchFault_ = 20;
  IndFreeKick_ = 21;
  PenaltySetup_ = 22;
  PenaltyReady_ = 23;
  PenaltyTaken_ = 24;
  PenaltyMiss_ = 25;
  PenaltyScore_ = 26;
  IllegalDefense_ = 27;
  PenaltyOnfield_ = 28;
  PenaltyFoul_ = 29;
  GoalieCatch_ = 30;
  ExtendHalf = 31;
  MODE_MAX = 32;
}

/**
  * WorldModel is the message that represents the world model in the soccer simulation. The WorldModel message contains all the information about the current state of the game.
*/
message WorldModel {
  InterceptTable intercept_table = 1; // The intercept table of the agent.
  string our_team_name = 2; // The name of our team.
  string their_team_name = 3; // The name of their team.
  Side our_side = 4; // The side of our team. It can be LEFT or RIGHT.
  int32 last_set_play_start_time = 5; // The last set play start time.
  Self self = 6; // The information about the agent itself.
  Ball ball = 7; // The information about the ball.
  repeated Player teammates = 8;
  repeated Player opponents = 9;
  repeated Player unknowns = 10;
  map<int32, Player> our_players_dict = 11;
  map<int32, Player> their_players_dict = 12;
 int32 our_goalie_uniform_number = 13; // The uniform number of our goalie.
  int32 their_goalie_uniform_number = 14; // The uniform number of their goalie.
  float offside_line_x = 15; // The x-coordinate of the offside line of opponent team.
  int32 ofside_line_x_count = 16; // How many cycles ago the agent has seen (calculated) the offside line.
  int32 kickable_teammate_id = 17; // The ID of the kickable teammate. To get the information about the kickable teammate, you can find a player in teammates or our_players_dict with this ID.
  int32 kickable_opponent_id = 18; // The ID of the kickable opponent. To get the information about the kickable opponent, you can find a player in opponents or their_players_dict with this ID.
  Side last_kick_side = 19; // The last side that the ball was kicked.
  int32 last_kicker_uniform_number = 20; // The last uniform number that the ball was kicked.
  int32 cycle = 21; // The current cycle of the game.
  GameModeType game_mode_type = 22; // The current game mode type.
  int32 left_team_score = 23; // The score of the left team.
  int32 right_team_score = 24; // The score of the right team.
  bool is_our_set_play = 25; // Whether it is our set play or not.
  bool is_their_set_play = 26; // Whether it is their set play or not.
  int32 stoped_cycle = 27; // The number of cycles that the game has stopped. For example, when the cycle is 90, and stoped_cycle is 10, it means the game has stopped at 90th cycle for 10 cycles.
  int32 our_team_score = 28; // The score of our team.
  int32 their_team_score = 29; // The score of their team.
  bool is_penalty_kick_mode = 30; // Whether it is penalty kick mode or not.
  map<int32, RpcVector2D> helios_home_positions = 31; // The home positions of the agents in the helios strategy. Helios base code is using Delanaray triangulation to calculate the home positions.
  double our_defense_line_x = 32; // The x-coordinate of our defense line. The diffence line is minimum x-coordinate of our players (except goalie) and ball.
  double their_defense_line_x = 33; // The x-coordinate of their defense line. The diffence line is minimum x-coordinate of their players (except goalie) and ball.
  double our_defense_player_line_x = 34; // The x-coordinate of our defense player line. The diffence player line is minimum x-coordinate of our players (except goalie).
  double their_defense_player_line_x = 35; // The x-coordinate of their defense player line. The diffence player line is minimum x-coordinate of their players (except goalie).
  bool kickable_teammate_existance = 36; // Whether the kickable teammate exists or not.
  bool kickable_opponent_existance = 37; // Whether the kickable opponent exists or not.
  PenaltyKickState penalty_kick_state = 38; // The penalty kick state.
  int32 see_time = 39; // The time that the agent has seen the world model.
  int32 time_stopped = 40;
  int32 set_play_count = 41;
  Side game_mode_side = 42;
}

/**
  * State is the message that represents the state of the agent in the soccer simulation.
*/
message State {
  RegisterResponse register_response = 1; // The response of the agent registration. The agent should use this information to identify itself to the playermaker server.
  WorldModel world_model = 2; // The world model of the agent. The agent should use this information to make decisions. If the server is in full state mode, the world model will be full state without noise.
  WorldModel full_world_model = 3; // The full world model of the agent. This value will be set only if the server is in full state mode and proxy agent is in debug mode. TODO add more information
  bool need_preprocess = 4; // Whether the agent needs to preprocess the world model or not. If the agent needs to do some preprocessing actions, it means the proxy agent will igonre the playmaker actions, you can ignore preprocessing.
}

/**
  * AgentType is the enum that represents the different types of agents.
*/
enum AgentType {
  PlayerT = 0;
  CoachT = 1;
  TrainerT = 2;
}

message InitMessage {
  RegisterResponse register_response = 1;
  bool debug_mode = 2;
}

/**
  * Dash is the message that represents the dash action in the soccer simulation.
  * By using this action, agent can dash (run or walk) to a direction with a power.
  * The rcssserver, calculates the next position and velocity of the agent based on current position, velocity, power and direction.
*/
message Dash {
  float power = 1; // The power of the dash action. The power can be between -100 to 100. If the power is negative, the agent will dash in the backward direction by using two times of the power.
  float relative_direction = 2; // The relative direction of the dash action to the body direction of the agent. The direction can be between -180 to 180.
}

/**
  * Turn is the message that represents the turn action in the soccer simulation.
  * By using this action, agent can turn to a direction relative to the current body direction.
  * The rcssserver, calculates the next body direction of the agent based on current body direction, relative direction and velocity of the agent.
*/
message Turn {
  float relative_direction = 1; // The relative direction of the turn action to the body direction of the agent. The direction can be between -180 to 180.
}

message Kick {
  float power = 1;
  float relative_direction = 2;
}

message Tackle {
  float power_or_dir = 1;
  bool foul = 2;
}

message Catch {

}

message Move {
  float x = 1;
  float y = 2;
}

message TurnNeck {
  float moment = 1;
}

message ChangeView {
  ViewWidth view_width = 1;
}

message BallMessage {
  RpcVector2D  ball_position = 1;
  RpcVector2D  ball_velocity = 2;
}

message PassMessage {
  int32 receiver_uniform_number = 1;
  RpcVector2D  receiver_point = 2;
  RpcVector2D  ball_position = 3;
  RpcVector2D  ball_velocity = 4;
}

message InterceptMessage {
  bool our = 1;
  int32 uniform_number = 2;
  int32 cycle = 3;
}

message GoalieMessage {
  int32 goalie_uniform_number = 1;
  RpcVector2D  goalie_position = 2;
  float goalie_body_direction = 3;
}

message GoalieAndPlayerMessage {
  int32 goalie_uniform_number = 1;
  RpcVector2D  goalie_position = 2;
  float goalie_body_direction = 3;

  int32 player_uniform_number = 4;
  RpcVector2D  player_position = 5;
}

message OffsideLineMessage {
  float offside_line_x = 1;
}

message DefenseLineMessage {
  float defense_line_x = 1;
}

message WaitRequestMessage {
}

message SetplayMessage {
  int32 wait_step = 1;
}

message PassRequestMessage {
  RpcVector2D  target_point = 1;
}

message StaminaMessage {
  float stamina = 1;
}

message RecoveryMessage {
  float recovery = 1;
}

message StaminaCapacityMessage {
  float stamina_capacity = 1;
}

message DribbleMessage {
  RpcVector2D  target_point = 1;
  int32 queue_count = 2;
}

message BallGoalieMessage {
  RpcVector2D  ball_position = 1;
  RpcVector2D  ball_velocity = 2;

  RpcVector2D  goalie_position = 3;
  float goalie_body_direction = 4;
}

message OnePlayerMessage {
  int32 uniform_number = 1;
  RpcVector2D  position = 2;
}

message TwoPlayerMessage {
  int32 first_uniform_number = 1;
  RpcVector2D  first_position = 2;

  int32 second_uniform_number = 3;
  RpcVector2D  second_position = 4;
}

message ThreePlayerMessage {
  int32 first_uniform_number = 1;
  RpcVector2D  first_position = 2;

  int32 second_uniform_number = 3;
  RpcVector2D  second_position = 4;

  int32 third_uniform_number = 5;
  RpcVector2D  third_position = 6;
}

message SelfMessage {
  RpcVector2D  self_position = 1;
  float self_body_direction = 2;
  float self_stamina = 3;
}

message TeammateMessage {
  int32 uniform_number = 1;
  RpcVector2D  position = 2;
  float body_direction = 3;
}

message OpponentMessage {
  int32 uniform_number = 1;
  RpcVector2D  position = 2;
  float body_direction = 3;
}

message BallPlayerMessage {
  RpcVector2D  ball_position = 1;
  RpcVector2D  ball_velocity = 2;

  int32 uniform_number = 3;
  RpcVector2D  player_position = 4;
  float body_direction = 5;
}

message Say {
  oneof message {
    BallMessage ball_message = 1;
    PassMessage pass_message = 2;
    InterceptMessage intercept_message = 3;
    GoalieMessage goalie_message = 4;
    GoalieAndPlayerMessage goalie_and_player_message = 5;
    OffsideLineMessage offside_line_message = 6;
    DefenseLineMessage defense_line_message = 7;
    WaitRequestMessage wait_request_message = 8;
    SetplayMessage setplay_message = 9;
    PassRequestMessage pass_request_message = 10;
    StaminaMessage stamina_message = 11;
    RecoveryMessage recovery_message = 12;
    StaminaCapacityMessage stamina_capacity_message = 13;
    DribbleMessage dribble_message = 14;
    BallGoalieMessage ball_goalie_message = 15;
    OnePlayerMessage one_player_message = 16;
    TwoPlayerMessage two_player_message = 17;
    ThreePlayerMessage three_player_message = 18;
    SelfMessage self_message = 19;
    TeammateMessage teammate_message = 20;
    OpponentMessage opponent_message = 21;
    BallPlayerMessage ball_player_message = 22;
  }
}

message PointTo {
  float x = 1;
  float y = 2;
}

message PointToOf {

}

message AttentionTo {
  Side side = 1;
  int32 unum = 2;
}

message AttentionToOf {

}

message AddText{
  LoggerLevel level = 1;
  string message = 2;
}

message AddPoint{
  LoggerLevel level = 1;
  RpcVector2D  point = 2;
  string color = 3;
}

message AddLine{
  LoggerLevel level = 1;
  RpcVector2D  start = 2;
  RpcVector2D  end = 3;
  string color = 4;
}

message AddArc{
  LoggerLevel level = 1;
  RpcVector2D  center = 2;
  float radius = 3;
  float start_angle = 4;
  float span_angel = 5;
  string color = 6;
}

message AddCircle{
  LoggerLevel level = 1;
  RpcVector2D  center = 2;
  float radius = 3;
  string color = 4;
  bool fill = 5;
}

message AddTriangle{
  LoggerLevel level = 1;
  RpcVector2D  point1 = 2;
  RpcVector2D  point2 = 3;
  RpcVector2D  point3 = 4;
  string color = 5;
  bool fill = 6;
}

message AddRectangle{
  LoggerLevel level = 1;
  float left = 2;
  float top = 3;
  float length = 4;
  float width = 5;
  string color = 6;
  bool fill = 7;
}

message AddSector{
  LoggerLevel level = 1;
  RpcVector2D  center = 2;
  float min_radius = 3;
  float max_radius = 4;
  float start_angle = 5;
  float span_angel = 6;
  string color = 7;
  bool fill = 8;
}

message AddMessage{
  LoggerLevel level = 1;
  RpcVector2D  position = 2;
  string message = 3;
  string color = 4;
}

message Log {
  oneof log {
    AddText add_text = 1;
    AddPoint add_point = 2;
    AddLine add_line = 3;
    AddArc add_arc = 4;
    AddCircle add_circle = 5;
    AddTriangle add_triangle = 6;
    AddRectangle add_rectangle = 7;
    AddSector add_sector = 8;
    AddMessage add_message = 9;
  }
}

message DebugClient {
  string message = 1;
}

message Body_GoToPoint { // todo more variables
  RpcVector2D  target_point = 1;
  float distance_threshold = 2;
  float max_dash_power = 3;
}

message Body_SmartKick { // todo more variables
  RpcVector2D  target_point = 1;
  float first_speed = 2;
  float first_speed_threshold = 3;
  int32 max_steps = 4;
}

message Bhv_BeforeKickOff {
  RpcVector2D  point = 1;
}

message Bhv_BodyNeckToBall {
}

message Bhv_BodyNeckToPoint {
  RpcVector2D  point = 1;
}

message Bhv_Emergency {
}

message Bhv_GoToPointLookBall {
  RpcVector2D  target_point = 1;
  float distance_threshold = 2;
  float max_dash_power = 3;
}

message Bhv_NeckBodyToBall {
  float angle_buf = 1;
}

message Bhv_NeckBodyToPoint {
  RpcVector2D  point = 1;
  float angle_buf = 2;
}

message Bhv_ScanField {
}

message Body_AdvanceBall {
}

message Body_ClearBall {
}

message Body_Dribble {
  RpcVector2D  target_point = 1;
  float distance_threshold = 2;
  float dash_power = 3;
  int32 dash_count = 4;
  bool dodge = 5;
}

message Body_GoToPointDodge {
  RpcVector2D  target_point = 1;
  float dash_power = 2;
}

message Body_HoldBall {
  bool do_turn = 1;
  RpcVector2D  turn_target_point = 2;
  RpcVector2D  kick_target_point = 3;
}

message Body_Intercept {
  bool save_recovery = 1;
  RpcVector2D  face_point = 2;
}

message Body_KickOneStep {
  RpcVector2D  target_point = 1;
  float first_speed = 2;
  bool force_mode = 3;
}

message Body_StopBall {
}

message Body_StopDash {
  bool save_recovery = 1;
}

message Body_TackleToPoint {
  RpcVector2D  target_point = 1;
  float min_probability = 2;
  float min_speed = 3;
}

message Body_TurnToAngle {
  float angle = 1;
}

message Body_TurnToBall {
  int32 cycle = 1;
}

message Body_TurnToPoint {
  RpcVector2D  target_point = 1;
  int32 cycle = 2;
}

message Focus_MoveToPoint {
  RpcVector2D  target_point = 1;
}

message Focus_Reset {
}

message Neck_ScanField {
}

message Neck_ScanPlayers { // todo min/max_angle
}

message Neck_TurnToBallAndPlayer {
  Side side = 1;
  int32 uniform_number = 2;
  int32 count_threshold = 3;
}

message Neck_TurnToBallOrScan {
  int32 count_threshold = 1;
}

message Neck_TurnToBall {
}

message Neck_TurnToGoalieOrScan {
  int32 count_threshold = 1;
}

message Neck_TurnToLowConfTeammate {
}

message Neck_TurnToPlayerOrScan {
  Side side = 1;
  int32 uniform_number = 2;
  int32 count_threshold = 3;
}

message Neck_TurnToPoint {
  RpcVector2D  target_point = 1;
}

message Neck_TurnToRelative {
  float angle = 1;
}

message View_ChangeWidth {
  ViewWidth view_width = 1;
}

message View_Normal {
}

message View_Synch {
}

message View_Wide {
}

message HeliosGoalie {}

message HeliosGoalieMove {}

message HeliosGoalieKick {}

message HeliosShoot {}

/**
  * HeliosOffensivePlanner is the message that represents the offensive planner of the agent in the soccer simulation.
  * The offensive planner is responsible for making decisions about the offensive actions of the agent by creating a tree of actions, 
    finding the best chain of actions, and executing the first action in the chain, when the agent is ball owner.
  * The best action is an action with best incomming predicted state.
  * The best predicted state is the state that has the best evaluation value by using this formula: value = ball.x + max(0.0, 40.0 - ball.dist(opponent goal center))
  * Due to the complexity of the not simple actions, the agent can not calculate the best action in the first layer of the tree. So, the agent can use the simple actions in the first layer of the tree.
  * To create the tree, the planner create all possible edges (actions) and create the next state of the agent by using each action.
    Then the planner starts to create the next layer of the tree by using the next state of the agent. The planner continues to create the tree until 
    the max depth of the tree or number of edges is reached.
  * For more information check this paper: [HELIOS Base: An Open Source Package for the RoboCup Soccer 2D Simulation](https://link.springer.com/chapter/10.1007/978-3-662-44468-9_46)

  Creating the tree and find best predicted state and action:

  ```mermaid
    flowchart TD
      wm[World Model]
      s0((PredictState 0))
      wm --> s0
      s1((PredictState 1))
      s2((PredictState 2))
      s3((PredictState 3))
      s4((PredictState 4))

      s0 == DirectPass ==> s1
      s0 == DirectPass ==> s2
      s0 == ShortDribble ==> s3
      s0 == Cross:BestAction ==> s4

      s5((PredictState 5))
      s6((PredictState 6))
      s7((PredictState 7))
      s8((PredictState 8))
      s9((PredictState 9))
      s10[PredictState 10
      Best State]

      s1 -. SimplePass .-> s5
      s1 -- SimpleDribble --> s6
      s2 -. SimplePass .-> s7
      s3 -- SimpleDribble --> s8
      s4 -. SimplePass .-> s9
      s4 -. SimplePass .-> s10

      s11((PredictState 11))
      s12((PredictState 12))

      s5 -. SimplePass .-> s11
      s5 -- SimpleDribble --> s12
  ```
  

*/
message HeliosOffensivePlanner {
  bool direct_pass = 1; /** Whether the agent can make a direct pass or not. 
  The direct pass is a pass action that the agent can pass the ball to the position of a teammate player. 
  This action is just used in the first layer of the tree. */
  bool lead_pass = 2; /** Whether the agent can make a lead pass or not. 
  The lead pass is a pass action that the agent can pass the ball to the position of a teammate player with a lead (very cloase to the teammate). 
  This action is just used in the first layer of the tree. */
  bool through_pass = 3; /** Whether the agent can make a through pass or not. 
  The through pass is a pass action that the agent can pass the ball to the position of a teammate player with a through (close or very far from the teammate, 
  between teammates and opponent goal). This action is just used in the first layer of the tree. */
  bool short_dribble = 4; /** Whether the agent can make a short dribble or not. The short dribble is a dribble action that the agent can dribble the ball to a position. 
  This action is just used in the first layer of the tree. */
  bool long_dribble = 5; /** Whether the agent can make a long dribble or not. The long dribble is a dribble action that the agent can dribble the ball to a position. 
  This dribble is longer than the short dribble. This action is just used in the first layer of the tree */
  bool cross = 6; /** Whether the agent can make a cross or not. The cross is a kick action that the agent can kick the ball to the position close to teammate, 
  but it does not care that the teammate can control the ball or not. This action is just used in the first layer of the tree. */
  bool simple_pass = 7; /** Whether the agent can make a simple pass or not. The simple pass is a pass action that the agent can pass the ball to the position of a teammate player. 
  This action is just used in the second or more layers of the tree. This action is not very accurate. */
  bool simple_dribble = 8; /** Whether the agent can make a simple dribble or not. The simple dribble is a dribble action that the agent can dribble the ball to a position. 
  This action is just used in the second or more layers of the tree. This action is not very accurate. */
  bool simple_shoot = 9; /** Whether the agent can make a simple shoot or not. The simple shoot is a kick action that the agent can kick the ball to the opponent goal. 
  This action is just used in the second or more layers of the tree. This action is not very accurate. */
  bool server_side_decision = 10; /** If this value is true, the proxy agent, will create the tree and send all of the nodes to the playmaker server to choose the best action. 
  If this value is false, the proxy agent will choose the best action by itself.
  The default value is false. */
  int32 max_depth = 11; /** The maximum depth of the tree. The agent will create the tree with this depth. To create the first layer of the tree, 
  the agent will use the direct_pass, lead_pass, through_pass, short_dribble, long_dribble, cross actions.  
  The difault value is 4. So, if you do not set this value, the agent will create the tree with 4 depth. Due to the default value of rpc, 0 means the default value. */
  int32 max_nodes = 12; /** The maximum number of nodes in the tree. The agent will create the tree with this number of nodes. 
  The difault value is 500. So, if you do not set this value, the agent will create the tree with 500 nodes. Due to the default value of rpc, 0 means the default value. */
  PlannerEvaluation evaluation = 13; /** The evaluation methods to evaluate the actions[predicted states] in the tree. */
}

/**
  * PlannerEvaluation is the message that represents the evaluation methods to evaluate the actions[predicted states] in the tree.
  * Using this method causes the predicted state eval to be decreased based on the distance or reach steps of the opponent players to the position of the ball in the predicted state.
  * Each variable in the message is a list of float values.
  * For example, if you want to decrease the predicted state eval if the distance of the opponent player to the ball is less than 5,
  You can set the negetive_effect_by_distance variable with the value of [-9.0, -8.5, -7.2, -6.1, -3.8]. It means the predicted state eval will be decreased by 9.0 if the distance is less than 1,
  8.5 if the distance is less than 2, 7.2 if the distance is less than 3, 6.1 if the distance is less than 4, 3.8 if the distance is less than 5.
  Example in python grpc:
  ```python
  actions = []
  opponent_effector = pb2.OpponentEffector(
      negetive_effect_by_distance=[-50, -45, -40, -30, -20, -15, -10, -5, -2, -1, -0.5, -0.1],
      negetive_effect_by_distance_based_on_first_layer=False,
      negetive_effect_by_reach_steps=[],
      negetive_effect_by_reach_steps_based_on_first_layer=False
  )
  planner_evaluation_effector = pb2.PlannerEvaluationEffector(
      opponent_effector=opponent_effector,
      # teammate_effector= ...
      # action_type_effector= ...
  )
  planner_evaluation = pb2.PlannerEvaluation(
      effectors=planner_evaluation_effector,
  )
  helios_offensive_planner = pb2.HeliosOffensivePlanner(
      lead_pass=True,
      direct_pass=False,
      through_pass=True,
      simple_pass=True,
      short_dribble=True,
      long_dribble=True,
      simple_shoot=True,
      simple_dribble=False,
      cross=True,
      server_side_decision=False,
      max_depth=5,
      max_nodes=800,
      evalution=planner_evaluation
  )
  actions.append(pb2.PlayerAction(helios_offensive_planner=helios_offensive_planner))
  return pb2.PlayerActions(actions=actions)
  ```
*/
message OpponentEffector {
  repeated float negetive_effect_by_distance = 1; /** The list of float values that represents the negetive effect of the distance of the opponent player to the ball in the predicted state. 
  The values of this list should be negetive numbers. */
  bool negetive_effect_by_distance_based_on_first_layer = 2;  /** If this value is true, the negetive_effect_by_distance will be calculated based on the first action of each action chain. 
  For example, if we have a chain of actions like [direct_pass, simple_pass, simple_dribble], the negetive_effect_by_distance will be calculated based on the direct_pass action for all of the actions. */
  repeated float negetive_effect_by_reach_steps = 3; /** The list of float values that represents the negetive effect of the reach steps of the opponent player to the ball in the predicted state. */
  bool negetive_effect_by_reach_steps_based_on_first_layer = 4; /** If this value is true, the negetive_effect_by_reach_steps will be calculated based on the first action of each action chain. 
  For example, if we have a chain of actions like [direct_pass, simple_pass, simple_dribble], the negetive_effect_by_reach_steps will be calculated based on the direct_pass action for all of the actions. */
}

/**
  * ActionTypeEffector is the message that represents coefficients of the action types in the tree to calculate the predicted state evaluation.
  * Each number should start from 0.0. For example, if evaluation of an action-state is 10, the action is direct pass, and value of direct_pass is 0.5, so the final evaluation of the action-state will be 5.
  example in python grpc:
  ```python
  actions = []
  action_type_effector = pb2.ActionTypeEffector(
      direct_pass=2.0,
      lead_pass=1.5,
      through_pass=1.0,
      short_dribble=1.0,
      long_dribble=1.0,
      cross=1.0,
      hold=1.0
  )
  planner_evaluation_effector = pb2.PlannerEvaluationEffector(
      # opponent_effector= ...
      # teammate_effector= ...
      action_type_effector= action_type_effector
  )
  planner_evaluation = pb2.PlannerEvaluation(
      effectors=planner_evaluation_effector,
  )
  helios_offensive_planner = pb2.HeliosOffensivePlanner(
      lead_pass=True,
      direct_pass=False,
      through_pass=True,
      simple_pass=True,
      short_dribble=True,
      long_dribble=True,
      simple_shoot=True,
      simple_dribble=False,
      cross=True,
      server_side_decision=False,
      max_depth=5,
      max_nodes=800,
      evalution=planner_evaluation
  )
  actions.append(pb2.PlayerAction(helios_offensive_planner=helios_offensive_planner))
  return pb2.PlayerActions(actions=actions)
  ```
*/
message ActionTypeEffector {
  float direct_pass = 1; /** The coefficient of the direct pass action. */
  float lead_pass = 2; /** The coefficient of the lead pass action. */
  float through_pass = 3; /** The coefficient of the through pass action. */
  float short_dribble = 4; /** The coefficient of the short dribble action. */
  float long_dribble = 5; /** The coefficient of the long dribble action. */
  float cross = 6; /** The coefficient of the cross action. */
  float hold = 7; /** The coefficient of the hold action. */
}

/**
  * TeammateEffector is the message that represents the coefficients of the teammates in the tree to calculate the predicted state evaluation.
  * Each number should start from 0.0. For example, if evaluation of an action-state is 10, the action is direct pass to player 5, 
  and value of player 5 is 0.5, so the final evaluation of the action-state will be 5.
  example in python grpc:
  ```python
  actions = []
  teammate_effector = pb2.TeammateEffector(
      coefficients={2: 1.2, 5: 1.6}, # if action target is player 2, multiply by 1.2.
      apply_based_on_first_layer=False
  )
  planner_evaluation_effector = pb2.PlannerEvaluationEffector(
      # opponent_effector= ...
      teammate_effector= teammate_effector
      # action_type_effector= ...
  )
  planner_evaluation = pb2.PlannerEvaluation(
      effectors=planner_evaluation_effector,
  )
  helios_offensive_planner = pb2.HeliosOffensivePlanner(
      lead_pass=True,
      direct_pass=False,
      through_pass=True,
      simple_pass=True,
      short_dribble=True,
      long_dribble=True,
      simple_shoot=True,
      simple_dribble=False,
      cross=True,
      server_side_decision=False,
      max_depth=5,
      max_nodes=800,
      evalution=planner_evaluation
  )
  actions.append(pb2.PlayerAction(helios_offensive_planner=helios_offensive_planner))
  return pb2.PlayerActions(actions=actions)
  ```
*/
message TeammateEffector {
  map<int32, float> coefficients = 1; /** The map of the coefficients of the teammates. The key of the map is the uniform number of the teammate, and the value is the coefficient of the teammate. 
  The value should be started from 0.0. */
  bool apply_based_on_first_layer = 2; /** If this value is true, the coefficients will be calculated based on the first action target of each action chain.
  For example, if we have a chain of actions like [direct_pass to 5, simple_pass to 6, simple_pass to 7], the coefficients will be calculated based on the coeeficient of the player 5 for all of the actions. */
}

/**
  * PlannerEvaluationEffector is the message that represents the effectors of the planner evaluation methods.
  * The proxy agent will update the predicted state evaluation based on the effectors.
  example in python grpc:
  ```python
  actions = []
  teammate_effector = pb2.TeammateEffector(
      coefficients={2: 1.2, 5: 1.6}, # if action target is player 2, multiply by 1.2.
      apply_based_on_first_layer=False
  )
  action_type_effector = pb2.ActionTypeEffector(
      direct_pass=2.0,
      lead_pass=1.5,
      through_pass=1.0,
      short_dribble=1.0,
      long_dribble=1.0,
      cross=1.0,
      hold=1.0
  )
  opponent_effector = pb2.OpponentEffector(
      negetive_effect_by_distance=[-50, -45, -40, -30, -20, -15, -10, -5, -2, -1, -0.5, -0.1],
      negetive_effect_by_distance_based_on_first_layer=False,
      negetive_effect_by_reach_steps=[],
      negetive_effect_by_reach_steps_based_on_first_layer=False
  )
  planner_evaluation_effector = pb2.PlannerEvaluationEffector(
      opponent_effector= opponent_effector,
      teammate_effector= teammate_effector,
      action_type_effector= action_type_effector
  )
  planner_evaluation = pb2.PlannerEvaluation(
      effectors=planner_evaluation_effector,
  )
  helios_offensive_planner = pb2.HeliosOffensivePlanner(
      lead_pass=True,
      direct_pass=False,
      through_pass=True,
      simple_pass=True,
      short_dribble=True,
      long_dribble=True,
      simple_shoot=True,
      simple_dribble=False,
      cross=True,
      server_side_decision=False,
      max_depth=5,
      max_nodes=800,
      evalution=planner_evaluation
  )
  actions.append(pb2.PlayerAction(helios_offensive_planner=helios_offensive_planner))
  return pb2.PlayerActions(actions=actions)
  ```
*/
message PlannerEvaluationEffector {
  OpponentEffector opponent_effector = 1; /** The effector of the opponent players. You can set the negetive effect of the distance or reach steps of the opponent players to the ball in the predicted state.
  By using this effector, the proxy agent will decrease the predicted state evaluation based on the distance or reach steps of the opponent players to the ball in the predicted state. */
  ActionTypeEffector action_type_effector = 2; /** The effector of the action types. You can set the coefficients of the action types in the tree to calculate the predicted state evaluation.
  By using this effector, the proxy agent will update the predicted state evaluation based on the coefficients of the action types in the tree. */
  TeammateEffector teammate_effector = 3; /** The effector of the teammates. You can set the coefficients of the teammates in the tree to calculate the predicted state evaluation.
  By using this effector, the proxy agent will update the predicted state evaluation based on the coefficients of the teammates in the tree. */
}

/**
  * HeliosFieldEvaluator is the message that represents the field evaluator of the proxy agent to evaluate each node (predicted state) in the planner tree.
  * If you dont set the field evaluator, the proxy agent will use the default field evaluator (HeliosFieldEvaluator) to evaluate each node in the planner tree.
  * This field evaluator calculate the value of the predicted state by using this formula: 
  value = x_coefficient * (ball.x + 52.5) + ball_dist_to_goal_coefficient * max(0.0, effective_max_ball_dist_to_goal - ball.dist(opponent goal center))
  example in python grpc:
  ```python
  actions = []
  helios_field_evaluator = pb2.HeliosFieldEvaluator(
      x_coefficient=2.1,
      ball_dist_to_goal_coefficient=1.8,
      effective_max_ball_dist_to_goal=50.0
  )
  field_evaluator = pb2.PlannerFieldEvaluator(
      helios_field_evaluator=helios_field_evaluator,
      # matrix_field_evaluator=...
  )
  planner_evaluation = pb2.PlannerEvaluation(
      field_evaluators=field_evaluator
  )
  helios_offensive_planner = pb2.HeliosOffensivePlanner(
      lead_pass=True,
      direct_pass=False,
      through_pass=True,
      simple_pass=True,
      short_dribble=True,
      long_dribble=True,
      simple_shoot=True,
      simple_dribble=False,
      cross=True,
      server_side_decision=False,
      max_depth=5,
      max_nodes=800,
      evalution=planner_evaluation
  )
  actions.append(pb2.PlayerAction(helios_offensive_planner=helios_offensive_planner))
  return pb2.PlayerActions(actions=actions)
  ```
*/
message HeliosFieldEvaluator {
  float x_coefficient = 1; // The coefficient of the x-coordinate of the ball in the predicted state. The default value is 1.
  float ball_dist_to_goal_coefficient = 2; // The coefficient of the distance of the ball to the opponent goal center in the predicted state. The default value is 1.
  float effective_max_ball_dist_to_goal = 3; // The effective maximum distance of the ball to the opponent goal center in the predicted state. The default value is 40.0.
}

message MatrixFieldEvaluatorY {
  repeated float evals = 1;
}

/**
  * MatrixFieldEvaluator is the message that represents the matrix field evaluator of the proxy agent to evaluate each node (predicted state) in the planner tree.
  * If you dont set the field evaluator, the proxy agent will use the default field evaluator (HeliosFieldEvaluator) to evaluate each node in the planner tree.
  * This field evaluator calculate the value of the predicted state by using a matrix of float values.
  * ---------------------
  * | 10 | 20 | 30 | 40 | 
  * | 15 | 25 | 35 | 45 |
  * | 10 | 20 | 30 | 40 |
  * ---------------------
  * In this example matrix, the value of each point in the opponent pernaly area is 45.
  * example in python grpc:
  ```python
  actions = []
  matrix_field_evaluator = pb2.MatrixFieldEvaluator(
      evals=[
          pb2.MatrixFieldEvaluatorY(evals=[10, 15, 10]),
          pb2.MatrixFieldEvaluatorY(evals=[20, 25, 20]),
          pb2.MatrixFieldEvaluatorY(evals=[30, 35, 30]),
          pb2.MatrixFieldEvaluatorY(evals=[40, 45, 40]),
      ]
  )
  field_evaluator = pb2.PlannerFieldEvaluator(
      # helios_field_evaluator=...
      matrix_field_evaluator=matrix_field_evaluator
  )
  planner_evaluation = pb2.PlannerEvaluation(
      field_evaluators=field_evaluator
  )
  helios_offensive_planner = pb2.HeliosOffensivePlanner(
      lead_pass=True,
      direct_pass=False,
      through_pass=True,
      simple_pass=True,
      short_dribble=True,
      long_dribble=True,
      simple_shoot=True,
      simple_dribble=False,
      cross=True,
      server_side_decision=False,
      max_depth=5,
      max_nodes=800,
      evalution=planner_evaluation
  )
  actions.append(pb2.PlayerAction(helios_offensive_planner=helios_offensive_planner))
  return pb2.PlayerActions(actions=actions)
  ```
*/
message MatrixFieldEvaluator {
  repeated MatrixFieldEvaluatorY evals = 1;
}

/**
  * PlannerFieldEvaluator is the message that represents the field evaluator of the proxy agent to evaluate each node (predicted state) in the planner tree.
  * If you dont set the field evaluator, the proxy agent will use the default field evaluator (HeliosFieldEvaluator) to evaluate each node in the planner tree.
  * This field evaluator calculate the value of the predicted state by using helios_field_evaluator or/and matrix_field_evaluator.
  * Note: if you just use the matrix_field_evaluator, value of all target in each square of the matrix should be the same, so it causes that the player choosing hold ball action instead of dribble in that area.
  * To avoid this issue, you can use the helios_field_evaluator with the matrix_field_evaluator together.
*/
message PlannerFieldEvaluator {
  HeliosFieldEvaluator helios_field_evaluator = 1;
  MatrixFieldEvaluator matrix_field_evaluator = 2;
}

/**
  * PlannerEvaluation is the message that represents the evaluation methods to evaluate the actions[predicted states] in the tree.
  * Using this method causes the predicted state eval to be calculated based on field evaluators and effected by effectors.
*/
message PlannerEvaluation {
  PlannerEvaluationEffector effectors = 1;
  PlannerFieldEvaluator field_evaluators = 2;
}

message HeliosBasicOffensive {}

message HeliosBasicMove {}

message HeliosSetPlay {}

message HeliosPenalty {}

message HeliosCommunicaion {}

message bhv_doForceKick {}

message bhv_doHeardPassRecieve {}

message PlayerAction {
  oneof action {
      Dash dash = 1;
      Turn turn = 2;
      Kick kick = 3;
      Tackle tackle = 4;
      Catch catch = 5;
      Move move = 6;
      TurnNeck turn_neck = 7;
      ChangeView change_view = 8;
      Say say = 9;
      PointTo point_to = 10;
      PointToOf point_to_of = 11;
      AttentionTo attention_to = 12;
      AttentionToOf attention_to_of = 13;
      Log log = 14;
      DebugClient debug_client = 15;
      Body_GoToPoint  body_go_to_point = 16;
      Body_SmartKick body_smart_kick = 17;
      Bhv_BeforeKickOff bhv_before_kick_off = 18;
      Bhv_BodyNeckToBall bhv_body_neck_to_ball = 19;
      Bhv_BodyNeckToPoint bhv_body_neck_to_point = 20;
      Bhv_Emergency bhv_emergency = 21;
      Bhv_GoToPointLookBall bhv_go_to_point_look_ball = 22;
      Bhv_NeckBodyToBall bhv_neck_body_to_ball = 23;
      Bhv_NeckBodyToPoint bhv_neck_body_to_point = 24;
      Bhv_ScanField bhv_scan_field = 25;
      Body_AdvanceBall body_advance_ball = 26;
      Body_ClearBall body_clear_ball = 27;
      Body_Dribble body_dribble = 28;
      Body_GoToPointDodge body_go_to_point_dodge = 29;
      Body_HoldBall body_hold_ball = 30;
      Body_Intercept body_intercept = 31;
      Body_KickOneStep body_kick_one_step = 32;
      Body_StopBall body_stop_ball = 33;
      Body_StopDash body_stop_dash = 34;
      Body_TackleToPoint body_tackle_to_point = 35;
      Body_TurnToAngle body_turn_to_angle = 36;
      Body_TurnToBall body_turn_to_ball = 37;
      Body_TurnToPoint body_turn_to_point = 38;
      Focus_MoveToPoint focus_move_to_point = 39;
      Focus_Reset focus_reset = 40;
      Neck_ScanField neck_scan_field = 41;
      Neck_ScanPlayers neck_scan_players = 42;
      Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player = 43;
      Neck_TurnToBallOrScan neck_turn_to_ball_or_scan = 44;
      Neck_TurnToBall neck_turn_to_ball = 45;
      Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan = 46;
      Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate = 47;
      Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan = 48;
      Neck_TurnToPoint neck_turn_to_point = 49;
      Neck_TurnToRelative neck_turn_to_relative = 50;
      View_ChangeWidth view_change_width = 51;
      View_Normal view_normal = 52;
      View_Synch view_synch = 53;
      View_Wide view_wide = 54;
      HeliosGoalie helios_goalie = 55;
      HeliosGoalieMove helios_goalie_move = 56;
      HeliosGoalieKick helios_goalie_kick = 57;
      HeliosShoot helios_shoot = 58;
      HeliosOffensivePlanner helios_offensive_planner = 59;
      HeliosBasicOffensive helios_basic_offensive = 60;
      HeliosBasicMove helios_basic_move = 61;
      HeliosSetPlay helios_set_play = 62;
      HeliosPenalty helios_penalty = 63;
      HeliosCommunicaion helios_communication = 64;
      bhv_doForceKick bhv_do_force_kick = 65;
      bhv_doHeardPassRecieve bhv_do_heard_pass_recieve = 66;

  }
}

message PlayerActions {
  repeated PlayerAction actions = 1;
  bool ignore_preprocess = 2;
  bool ignore_doforcekick = 3;
  bool ignore_doHeardPassRecieve = 4;
  bool ignore_doIntention = 5;
  bool ignore_shootInPreprocess = 6;
}

message ChangePlayerType {
  int32 uniform_number = 1;
  int32 type = 2;
}

message DoHeliosSubstitute {}

message DoHeliosSayPlayerTypes {}

message CoachAction {
  oneof action {
    ChangePlayerType change_player_types = 1;
    DoHeliosSubstitute do_helios_substitute = 2;
    DoHeliosSayPlayerTypes do_helios_say_player_types = 3;
  }
}

message CoachActions {
  repeated CoachAction actions = 1;
}

message DoKickOff {}

message DoMoveBall {
  RpcVector2D  position = 1;
  RpcVector2D  velocity = 2;
}

message DoMovePlayer {
  bool our_side = 1;
  int32 uniform_number = 2;
  RpcVector2D  position = 3;
  float body_direction = 4;
}

message DoRecover {}

message DoChangeMode {
  GameModeType game_mode_type = 1;
  Side side = 2; //some of the game mode need to know the side
}

message DoChangePlayerType {
  bool our_side = 1;
  int32 uniform_number = 2;
  int32 type = 3;
}

message TrainerAction {
  oneof action {
    DoKickOff do_kick_off = 1;
    DoMoveBall do_move_ball = 2;
    DoMovePlayer do_move_player = 3;
    DoRecover do_recover = 4;
    DoChangeMode do_change_mode = 5;
    DoChangePlayerType do_change_player_type = 6;
  }
}

message TrainerActions {
  repeated TrainerAction actions = 1;
}

message ServerParam {
  RegisterResponse register_response = 1;
  float inertia_moment = 2;
  float player_size = 3;
  float player_decay = 4;
  float player_rand = 5;
  float player_weight = 6;
  float player_speed_max = 7;
  float player_accel_max = 8;
  float stamina_max = 9;
  float stamina_inc_max = 10;
  float recover_init = 11;
  float recover_dec_thr = 12;
  float recover_min = 13;
  float recover_dec = 14;
  float effort_init = 15;
  float effort_dec_thr = 16;
  float effort_min = 17;
  float effort_dec = 18;
  float effort_inc_thr = 19;
  float effort_inc = 20;
  float kick_rand = 21;
  bool team_actuator_noise = 22;
  float player_rand_factor_l = 23;
  float player_rand_factor_r = 24;
  float kick_rand_factor_l = 25;
  float kick_rand_factor_r = 26;
  float ball_size = 27;
  float ball_decay = 28;
  float ball_rand = 29;
  float ball_weight = 30;
  float ball_speed_max = 31;
  float ball_accel_max = 32;
  float dash_power_rate = 33;
  float kick_power_rate = 34;
  float kickable_margin = 35;
  float control_radius = 36;
  float control_radius_width = 37;
  float max_power = 38;
  float min_power = 39;
  float max_moment = 40;
  float min_moment = 41;
  float max_neck_moment = 42;
  float min_neck_moment = 43;
  float max_neck_angle = 44;
  float min_neck_angle = 45;
  float visible_angle = 46;
  float visible_distance = 47;
  float wind_dir = 48;
  float wind_force = 49;
  float wind_angle = 50;
  float wind_rand = 51;
  float kickable_area = 52;
  float catch_area_l = 53;
  float catch_area_w = 54;
  float catch_probability = 55;
  int32 goalie_max_moves = 56;
  float corner_kick_margin = 57;
  float offside_active_area_size = 58;
  bool wind_none = 59;
  bool use_wind_random = 60;
  int32 coach_say_count_max = 61;
  int32 coach_say_msg_size = 62;
  int32 clang_win_size = 63;
  int32 clang_define_win = 64;
  int32 clang_meta_win = 65;
  int32 clang_advice_win = 66;
  int32 clang_info_win = 67;
  int32 clang_mess_delay = 68;
  int32 clang_mess_per_cycle = 69;
  int32 half_time = 70;
  int32 simulator_step = 71;
  int32 send_step = 72;
  int32 recv_step = 73;
  int32 sense_body_step = 74;
  int32 lcm_step = 75;
  int32 player_say_msg_size = 76;
  int32 player_hear_max = 77;
  int32 player_hear_inc = 78;
  int32 player_hear_decay = 79;
  int32 catch_ban_cycle = 80;
  int32 slow_down_factor = 81;
  bool use_offside = 82;
  bool kickoff_offside = 83;
  float offside_kick_margin = 84;
  float audio_cut_dist = 85;
  float dist_quantize_step = 86;
  float landmark_dist_quantize_step = 87;
  float dir_quantize_step = 88;
  float dist_quantize_step_l = 89;
  float dist_quantize_step_r = 90;
  float landmark_dist_quantize_step_l = 91;
  float landmark_dist_quantize_step_r = 92;
  float dir_quantize_step_l = 93;
  float dir_quantize_step_r = 94;
  bool coach_mode = 95;
  bool coach_with_referee_mode = 96;
  bool use_old_coach_hear = 97;
  float slowness_on_top_for_left_team = 98;
  float slowness_on_top_for_right_team = 99;
  int32 start_goal_l = 100;
  int32 start_goal_r = 101;
  bool fullstate_l = 102;
  bool fullstate_r = 103;
  int32 drop_ball_time = 104;
  bool synch_mode = 105;
  int32 synch_offset = 106;
  int32 synch_micro_sleep = 107;
  int32 point_to_ban = 108;
  int32 point_to_duration = 109;
  int32 player_port = 110;
  int32 trainer_port = 111;
  int32 online_coach_port = 112;
  bool verbose_mode = 113;
  int32 coach_send_vi_step = 114;
  string replay_file = 115;
  string landmark_file = 116;
  bool send_comms = 117;
  bool text_logging = 118;
  bool game_logging = 119;
  int32 game_log_version = 120;
  string text_log_dir = 121;
  string game_log_dir = 122;
  string text_log_fixed_name = 123;
  string game_log_fixed_name = 124;
  bool use_text_log_fixed = 125;
  bool use_game_log_fixed = 126;
  bool use_text_log_dated = 127;
  bool use_game_log_dated = 128;
  string log_date_format = 129;
  bool log_times = 130;
  bool record_message = 131;
  int32 text_log_compression = 132;
  int32 game_log_compression = 133;
  bool use_profile = 134;
  float tackle_dist = 135;
  float tackle_back_dist = 136;
  float tackle_width = 137;
  float tackle_exponent = 138;
  int32 tackle_cycles = 139;
  float tackle_power_rate = 140;
  int32 freeform_wait_period = 141;
  int32 freeform_send_period = 142;
  bool free_kick_faults = 143;
  bool back_passes = 144;
  bool proper_goal_kicks = 145;
  float stopped_ball_vel = 146;
  int32 max_goal_kicks = 147;
  int32 clang_del_win = 148;
  int32 clang_rule_win = 149;
  bool auto_mode = 150;
  int32 kick_off_wait = 151;
  int32 connect_wait = 152;
  int32 game_over_wait = 153;
  string team_l_start = 154;
  string team_r_start = 155;
  bool keepaway_mode = 156;
  float keepaway_length = 157;
  float keepaway_width = 158;
  bool keepaway_logging = 159;
  string keepaway_log_dir = 160;
  string keepaway_log_fixed_name = 161;
  bool keepaway_log_fixed = 162;
  bool keepaway_log_dated = 163;
  int32 keepaway_start = 164;
  int32 nr_normal_halfs = 165;
  int32 nr_extra_halfs = 166;
  bool penalty_shoot_outs = 167;
  int32 pen_before_setup_wait = 168;
  int32 pen_setup_wait = 169;
  int32 pen_ready_wait = 170;
  int32 pen_taken_wait = 171;
  int32 pen_nr_kicks = 172;
  int32 pen_max_extra_kicks = 173;
  float pen_dist_x = 174;
  bool pen_random_winner = 175;
  bool pen_allow_mult_kicks = 176;
  float pen_max_goalie_dist_x = 177;
  bool pen_coach_moves_players = 178;
  string module_dir = 179;
  float ball_stuck_area = 180;
  string coach_msg_file = 181;
  float max_tackle_power = 182;
  float max_back_tackle_power = 183;
  float player_speed_max_min = 184;
  float extra_stamina = 185;
  int32 synch_see_offset = 186;
  int32 extra_half_time = 187;
  float stamina_capacity = 188;
  float max_dash_angle = 189;
  float min_dash_angle = 190;
  float dash_angle_step = 191;
  float side_dash_rate = 192;
  float back_dash_rate = 193;
  float max_dash_power = 194;
  float min_dash_power = 195;
  float tackle_rand_factor = 196;
  float foul_detect_probability = 197;
  float foul_exponent = 198;
  int32 foul_cycles = 199;
  bool golden_goal = 200;
  float red_card_probability = 201;
  int32 illegal_defense_duration = 202;
  int32 illegal_defense_number = 203;
  float illegal_defense_dist_x = 204;
  float illegal_defense_width = 205;
  string fixed_teamname_l = 206;
  string fixed_teamname_r = 207;
  float max_catch_angle = 208;
  float min_catch_angle = 209;
  int32 random_seed = 210;
  float long_kick_power_factor = 211;
  int32 long_kick_delay = 212;
  int32 max_monitors = 213;
  float catchable_area = 214;
  float real_speed_max = 215;
  float pitch_half_length = 216;
  float pitch_half_width = 217;
  float our_penalty_area_line_x = 218;
  float their_penalty_area_line_x = 219;
  float penalty_area_half_width = 220;
  float penalty_area_length = 221;
  float goal_width = 222;
  float goal_area_width = 223;
  float goal_area_length = 224;
  float center_circle_r = 225;
  float goal_post_radius = 226;
}

message PlayerParam {
  RegisterResponse register_response = 1;
  int32 player_types = 2;
  int32 subs_max = 3;
  int32 pt_max = 4;
  bool allow_mult_default_type = 5;
  float player_speed_max_delta_min = 6;
  float player_speed_max_delta_max = 7;
  float stamina_inc_max_delta_factor = 8;
  float player_decay_delta_min = 9;
  float player_decay_delta_max = 10;
  float inertia_moment_delta_factor = 11;
  float dash_power_rate_delta_min = 12;
  float dash_power_rate_delta_max = 13;
  float player_size_delta_factor = 14;
  float kickable_margin_delta_min = 15;
  float kickable_margin_delta_max = 16;
  float kick_rand_delta_factor = 17;
  float extra_stamina_delta_min = 18;
  float extra_stamina_delta_max = 19;
  float effort_max_delta_factor = 20;
  float effort_min_delta_factor = 21;
  int32 random_seed = 22;
  float new_dash_power_rate_delta_min = 23;
  float new_dash_power_rate_delta_max = 24;
  float new_stamina_inc_max_delta_factor = 25;
  float kick_power_rate_delta_min = 26;
  float kick_power_rate_delta_max = 27;
  float foul_detect_probability_delta_factor = 28;
  float catchable_area_l_stretch_min = 29;
  float catchable_area_l_stretch_max = 30;
}

message PlayerType {
  RegisterResponse register_response = 1;
  int32 id = 2;
  float stamina_inc_max = 3;
  float player_decay = 4;
  float inertia_moment = 5;
  float dash_power_rate = 6;
  float player_size = 7;
  float kickable_margin = 8;
  float kick_rand = 9;
  float extra_stamina = 10;
  float effort_max = 11;
  float effort_min = 12;
  float kick_power_rate = 13;
  float foul_detect_probability = 14;
  float catchable_area_l_stretch = 15;
  float unum_far_length = 16;
  float unum_too_far_length = 17;
  float team_far_length = 18;
  float team_too_far_length = 19;
  float player_max_observation_length = 20;
  float ball_vel_far_length = 21;
  float ball_vel_too_far_length = 22;
  float ball_max_observation_length = 23;
  float flag_chg_far_length = 24;
  float flag_chg_too_far_length = 25;
  float flag_max_observation_length = 26;
  float kickable_area = 27;
  float reliable_catchable_dist = 28;
  float max_catchable_dist = 29;
  float real_speed_max = 30;
  float player_speed_max2 = 31;
  float real_speed_max2 = 32;
  int32 cycles_to_reach_max_speed = 33;
  float player_speed_max = 34;
}

enum RpcActionCategory {
  AC_Hold = 0;
  AC_Dribble = 1;
  AC_Pass = 2;
  AC_Shoot = 3;
  AC_Clear = 4;
  AC_Move = 5;
  AC_NoAction = 6;
}
message RpcCooperativeAction {
  RpcActionCategory category = 1;
  int32 index = 2;
  int32 sender_unum = 3;
  int32 target_unum = 4;
  RpcVector2D target_point = 5;
  double first_ball_speed = 6;
  double first_turn_moment = 7;
  double first_dash_power = 8;
  double first_dash_angle_relative = 9;
  int32 duration_step = 10;
  int32 kick_count = 11;
  int32 turn_count = 12;
  int32 dash_count = 13;
  bool final_action = 14;
  string description = 15;
  int32 parent_index = 16;
}

message RpcPredictState {
  int32 spend_time = 1;
  int32 ball_holder_unum = 2;
  RpcVector2D ball_position = 3;
  RpcVector2D ball_velocity = 4;
  double our_defense_line_x = 5;
  double our_offense_line_x = 6;
}

message RpcActionState {
  RpcCooperativeAction action = 1;
  RpcPredictState predict_state = 2;
  double evaluation = 3;
}

message BestPlannerActionRequest {
  RegisterResponse register_response = 1;
  map<int32, RpcActionState> pairs = 2;
  State state = 3;
}

message BestPlannerActionResponse {
  int32 index = 1;
}

message Empty {
}

service Game {
  /*
 * The Game service provides various RPC methods for interacting with a soccer simulation.
 * 
  ```mermaid
  sequenceDiagram
      participant SS as SoccerSimulationServer
      participant SP as SoccerSimulationProxy
      participant PM as PlayMakerServer
      Note over SS,PM: Run
      SP->>SS: Connect
      SS->>SP: OK, Unum
      SS->>SP: ServerParam
      SS->>SP: PlayerParam
      SS->>SP: PlayerType (0)
      SS->>SP: PlayerType (1)
      SS->>SP: PlayerType (17)
      SP->>PM: Register(RegisterRequest)
      PM->>SP: RegisterResponse
      SP->>PM: SendInitMessage(InitMessage)
      PM->>SP: Empty
      SP->>PM: SendServerParams(ServerParam)
      PM->>SP: Empty
      SP->>PM: SendPlayerParams(PlayerParam)
      PM->>SP: Empty
      SP->>PM: SendPlayerType(PlayerType(0))
      PM->>SP: Empty
      SP->>PM: SendPlayerType(PlayerType(1))
      PM->>SP: Empty
      SP->>PM: SendPlayerType(PlayerType(17))
      PM->>SP: Empty
      SS->>SP: Observation
      Note over SP: Convert observation to State
      SP->>PM: GetPlayerActions(State)
      PM->>SP: PlayerActions
      Note over SP: Convert Actions to Low-Level Commands
      SP->>SS: Commands
  ```
 */

  rpc GetPlayerActions(State) returns (PlayerActions) {}
  rpc GetCoachActions(State) returns (CoachActions) {}
  rpc GetTrainerActions(State) returns (TrainerActions) {}
  rpc SendInitMessage(InitMessage) returns (Empty) {}
  rpc SendServerParams(ServerParam) returns (Empty) {}
  rpc SendPlayerParams(PlayerParam) returns (Empty) {}
  rpc SendPlayerType(PlayerType) returns (Empty) {} //should be PlayerTypes
  rpc Register(RegisterRequest) returns (RegisterResponse) {}
  rpc SendByeCommand(RegisterResponse) returns (Empty) {}
  rpc GetBestPlannerAction(BestPlannerActionRequest) returns (BestPlannerActionResponse) {}
}
